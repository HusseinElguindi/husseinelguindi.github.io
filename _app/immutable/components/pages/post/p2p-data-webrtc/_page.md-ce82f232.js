import{S as mt,i as bt,s as yt,P as Me,v as kt,w as vt,x as wt,Q as _t,R as lt,f as gt,t as Tt,y as Et,T as pt,k as o,q as c,a as d,l as r,m as i,h as t,r as u,c as h,n as l,b as n,H as a,A as Rt}from"../../../../chunks/index-6e1e08c5.js";import{P as xt}from"../../../../chunks/_post-3c519d6a.js";function At(U){let p,m,y,C,f,b,z,Y,v,w,J,be,Z,S,ye,ee,_,ke,D,ve,we,te,g,T,Q,_e,ae,E,ge,W,Te,Ee,se,R,x,G,Re,ne,$,xe,oe,I,j,ut=`<span class="token comment">// main.go</span>
<span class="token keyword">var</span> rooms <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">*</span>User<span class="token punctuation">)</span>

<span class="token keyword">type</span> User <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	<span class="token operator">*</span>websocket<span class="token punctuation">.</span>Conn
    <span class="token operator">...</span>
	pair <span class="token operator">*</span>User <span class="token comment">// the user's peer</span>
<span class="token punctuation">&#125;</span>`,re,k,Ae,K,Pe,Ce,V,De,We,ie,H,Ie,le,A,P,X,Ne,pe,q,Ue,ce,N,L,ft=`<span class="token keyword">let</span> <span class="token literal-property property">data</span><span class="token operator">:</span> ArrayBuffer<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">/* on data chunk receive */</span>
data<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>chunkData<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/* on data save/download */</span>
<span class="token keyword">const</span> received <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Blob</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> <span class="token literal-property property">type</span><span class="token operator">:</span> mime <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
downloadAnchor<span class="token punctuation">.</span>href <span class="token operator">=</span> <span class="token constant">URL</span><span class="token punctuation">.</span><span class="token function">createObjectURL</span><span class="token punctuation">(</span>received<span class="token punctuation">)</span><span class="token punctuation">;</span>
downloadAnchor<span class="token punctuation">.</span>download <span class="token operator">=</span> filename<span class="token punctuation">;</span>
downloadAnchor<span class="token punctuation">.</span><span class="token function">click</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>`,ue,M,ze,fe,O,Se,de,B,$e;return{c(){p=o("h2"),m=o("a"),y=o("span"),C=c("The Problem"),f=d(),b=o("p"),z=c("It is quite often that I find myself needing to transfer files between devices. It usually resolves into sending files through email, a form of social media, or some other untrusted file hosting platform."),Y=d(),v=o("h2"),w=o("a"),J=o("span"),be=c("WebRTC"),Z=d(),S=o("p"),ye=c("WebRTC is an open source project that provides an interface for peer to peer communication between devices. Using WebRTC\u2019s data channels, we can send data completely securely from one peer to another, without a middle man (assuming that a connection is made without a TURN server)."),ee=d(),_=o("p"),ke=c("Using WebRTC, I decided to create "),D=o("a"),ve=c("DropNow"),we=c("."),te=d(),g=o("h2"),T=o("a"),Q=o("span"),_e=c("DropNow"),ae=d(),E=o("p"),ge=c("DropNow is a free service designed to fix the convenience, privacy, and quality issues of data sharing today. It is available now at "),W=o("a"),Te=c("dropnow.elguindi.xyz"),Ee=c(". Try it out!"),se=d(),R=o("h3"),x=o("a"),G=o("span"),Re=c("Technical Details"),ne=d(),$=o("p"),xe=c("DropNow uses a room-type signalling server to enable peer to peer WebRTC connections. A user can create a room, identified by a room name (the string that they input on the homepage of the website). From there, another user can join that room by entering the same room name; there can only be 2 users in one room at a time. The room system is in place to allow for the relaying of messages from peer to the other."),oe=d(),I=o("pre"),j=o("code"),re=d(),k=o("p"),Ae=c("The signalling server handles websocket connections from every user on a new goroutine, when a message is received from a "),K=o("code"),Pe=c("User"),Ce=c(", it is relayed to the "),V=o("code"),De=c("User.pair"),We=c("."),ie=d(),H=o("p"),Ie=c("After the WebRTC connection is made through the signalling server, the signalling server is not used for any data transfer other than for WebRTC purposes (like renegotiation). Nobody sees your data except you and the connected peer."),le=d(),A=o("h3"),P=o("a"),X=o("span"),Ne=c("Technical Limitations and Solutions"),pe=d(),q=o("p"),Ue=c("Due to the nature of storing JavaScript blobs on mobile devices, it is not possible to transfer large files (greater than ~300MiB). To download a file, we store the received blobs from WebRTC in an array, then, once all blobs are received, a data URI is generated from the array for the download. This results in the need for the browser to be able to store 2 times the size of the transferred data."),ce=d(),N=o("pre"),L=o("code"),ue=d(),M=o("p"),ze=c("If a better filesystem API comes along in the future, it should theoretically be possible to transfer files of any size, writing directly to non-volatile storage, as opposed to memory."),fe=d(),O=o("p"),Se=c("For desktop browsers, they have a greater capacity (due to larger RAM size) and have some caching ability to store large blobs. I currently do not see an issue with large file transfers to a desktop browser."),de=d(),B=o("p"),$e=c("A current possible solution would consist of desktop or mobile applications to handle the data transfer, writing directly to the disk with a small in-memory buffer. This would mean that the download size is not limited by the memory of the device, but its physical storage."),this.h()},l(e){p=r(e,"H2",{id:!0});var s=i(p);m=r(s,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var Oe=i(m);y=r(Oe,"SPAN",{class:!0}),i(y).forEach(t),Oe.forEach(t),C=u(s,"The Problem"),s.forEach(t),f=h(e),b=r(e,"P",{});var Be=i(b);z=u(Be,"It is quite often that I find myself needing to transfer files between devices. It usually resolves into sending files through email, a form of social media, or some other untrusted file hosting platform."),Be.forEach(t),Y=h(e),v=r(e,"H2",{id:!0});var je=i(v);w=r(je,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var Fe=i(w);J=r(Fe,"SPAN",{class:!0}),i(J).forEach(t),Fe.forEach(t),be=u(je,"WebRTC"),je.forEach(t),Z=h(e),S=r(e,"P",{});var Je=i(S);ye=u(Je,"WebRTC is an open source project that provides an interface for peer to peer communication between devices. Using WebRTC\u2019s data channels, we can send data completely securely from one peer to another, without a middle man (assuming that a connection is made without a TURN server)."),Je.forEach(t),ee=h(e),_=r(e,"P",{});var he=i(_);ke=u(he,"Using WebRTC, I decided to create "),D=r(he,"A",{href:!0,rel:!0});var Qe=i(D);ve=u(Qe,"DropNow"),Qe.forEach(t),we=u(he,"."),he.forEach(t),te=h(e),g=r(e,"H2",{id:!0});var He=i(g);T=r(He,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var Ge=i(T);Q=r(Ge,"SPAN",{class:!0}),i(Q).forEach(t),Ge.forEach(t),_e=u(He,"DropNow"),He.forEach(t),ae=h(e),E=r(e,"P",{});var me=i(E);ge=u(me,"DropNow is a free service designed to fix the convenience, privacy, and quality issues of data sharing today. It is available now at "),W=r(me,"A",{href:!0,rel:!0});var Ke=i(W);Te=u(Ke,"dropnow.elguindi.xyz"),Ke.forEach(t),Ee=u(me,". Try it out!"),me.forEach(t),se=h(e),R=r(e,"H3",{id:!0});var qe=i(R);x=r(qe,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var Ve=i(x);G=r(Ve,"SPAN",{class:!0}),i(G).forEach(t),Ve.forEach(t),Re=u(qe,"Technical Details"),qe.forEach(t),ne=h(e),$=r(e,"P",{});var Xe=i($);xe=u(Xe,"DropNow uses a room-type signalling server to enable peer to peer WebRTC connections. A user can create a room, identified by a room name (the string that they input on the homepage of the website). From there, another user can join that room by entering the same room name; there can only be 2 users in one room at a time. The room system is in place to allow for the relaying of messages from peer to the other."),Xe.forEach(t),oe=h(e),I=r(e,"PRE",{class:!0});var Ye=i(I);j=r(Ye,"CODE",{class:!0});var dt=i(j);dt.forEach(t),Ye.forEach(t),re=h(e),k=r(e,"P",{});var F=i(k);Ae=u(F,"The signalling server handles websocket connections from every user on a new goroutine, when a message is received from a "),K=r(F,"CODE",{});var Ze=i(K);Pe=u(Ze,"User"),Ze.forEach(t),Ce=u(F,", it is relayed to the "),V=r(F,"CODE",{});var et=i(V);De=u(et,"User.pair"),et.forEach(t),We=u(F,"."),F.forEach(t),ie=h(e),H=r(e,"P",{});var tt=i(H);Ie=u(tt,"After the WebRTC connection is made through the signalling server, the signalling server is not used for any data transfer other than for WebRTC purposes (like renegotiation). Nobody sees your data except you and the connected peer."),tt.forEach(t),le=h(e),A=r(e,"H3",{id:!0});var Le=i(A);P=r(Le,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var at=i(P);X=r(at,"SPAN",{class:!0}),i(X).forEach(t),at.forEach(t),Ne=u(Le,"Technical Limitations and Solutions"),Le.forEach(t),pe=h(e),q=r(e,"P",{});var st=i(q);Ue=u(st,"Due to the nature of storing JavaScript blobs on mobile devices, it is not possible to transfer large files (greater than ~300MiB). To download a file, we store the received blobs from WebRTC in an array, then, once all blobs are received, a data URI is generated from the array for the download. This results in the need for the browser to be able to store 2 times the size of the transferred data."),st.forEach(t),ce=h(e),N=r(e,"PRE",{class:!0});var nt=i(N);L=r(nt,"CODE",{class:!0});var ht=i(L);ht.forEach(t),nt.forEach(t),ue=h(e),M=r(e,"P",{});var ot=i(M);ze=u(ot,"If a better filesystem API comes along in the future, it should theoretically be possible to transfer files of any size, writing directly to non-volatile storage, as opposed to memory."),ot.forEach(t),fe=h(e),O=r(e,"P",{});var rt=i(O);Se=u(rt,"For desktop browsers, they have a greater capacity (due to larger RAM size) and have some caching ability to store large blobs. I currently do not see an issue with large file transfers to a desktop browser."),rt.forEach(t),de=h(e),B=r(e,"P",{});var it=i(B);$e=u(it,"A current possible solution would consist of desktop or mobile applications to handle the data transfer, writing directly to the disk with a small in-memory buffer. This would mean that the download size is not limited by the memory of the device, but its physical storage."),it.forEach(t),this.h()},h(){l(y,"class","icon icon-link"),l(m,"aria-hidden","true"),l(m,"tabindex","-1"),l(m,"href","#the-problem"),l(p,"id","the-problem"),l(J,"class","icon icon-link"),l(w,"aria-hidden","true"),l(w,"tabindex","-1"),l(w,"href","#webrtc"),l(v,"id","webrtc"),l(D,"href","https://dropnow.elguindi.xyz"),l(D,"rel","nofollow"),l(Q,"class","icon icon-link"),l(T,"aria-hidden","true"),l(T,"tabindex","-1"),l(T,"href","#dropnow"),l(g,"id","dropnow"),l(W,"href","https://dropnow.elguindi.xyz"),l(W,"rel","nofollow"),l(G,"class","icon icon-link"),l(x,"aria-hidden","true"),l(x,"tabindex","-1"),l(x,"href","#technical-details"),l(R,"id","technical-details"),l(j,"class","language-go"),l(I,"class","language-go"),l(X,"class","icon icon-link"),l(P,"aria-hidden","true"),l(P,"tabindex","-1"),l(P,"href","#technical-limitations-and-solutions"),l(A,"id","technical-limitations-and-solutions"),l(L,"class","language-js"),l(N,"class","language-js")},m(e,s){n(e,p,s),a(p,m),a(m,y),a(p,C),n(e,f,s),n(e,b,s),a(b,z),n(e,Y,s),n(e,v,s),a(v,w),a(w,J),a(v,be),n(e,Z,s),n(e,S,s),a(S,ye),n(e,ee,s),n(e,_,s),a(_,ke),a(_,D),a(D,ve),a(_,we),n(e,te,s),n(e,g,s),a(g,T),a(T,Q),a(g,_e),n(e,ae,s),n(e,E,s),a(E,ge),a(E,W),a(W,Te),a(E,Ee),n(e,se,s),n(e,R,s),a(R,x),a(x,G),a(R,Re),n(e,ne,s),n(e,$,s),a($,xe),n(e,oe,s),n(e,I,s),a(I,j),j.innerHTML=ut,n(e,re,s),n(e,k,s),a(k,Ae),a(k,K),a(K,Pe),a(k,Ce),a(k,V),a(V,De),a(k,We),n(e,ie,s),n(e,H,s),a(H,Ie),n(e,le,s),n(e,A,s),a(A,P),a(P,X),a(A,Ne),n(e,pe,s),n(e,q,s),a(q,Ue),n(e,ce,s),n(e,N,s),a(N,L),L.innerHTML=ft,n(e,ue,s),n(e,M,s),a(M,ze),n(e,fe,s),n(e,O,s),a(O,Se),n(e,de,s),n(e,B,s),a(B,$e)},p:Rt,d(e){e&&t(p),e&&t(f),e&&t(b),e&&t(Y),e&&t(v),e&&t(Z),e&&t(S),e&&t(ee),e&&t(_),e&&t(te),e&&t(g),e&&t(ae),e&&t(E),e&&t(se),e&&t(R),e&&t(ne),e&&t($),e&&t(oe),e&&t(I),e&&t(re),e&&t(k),e&&t(ie),e&&t(H),e&&t(le),e&&t(A),e&&t(pe),e&&t(q),e&&t(ce),e&&t(N),e&&t(ue),e&&t(M),e&&t(fe),e&&t(O),e&&t(de),e&&t(B)}}}function Pt(U){let p,m;const y=[U[0],ct];let C={$$slots:{default:[At]},$$scope:{ctx:U}};for(let f=0;f<y.length;f+=1)C=Me(C,y[f]);return p=new xt({props:C}),{c(){kt(p.$$.fragment)},l(f){vt(p.$$.fragment,f)},m(f,b){wt(p,f,b),m=!0},p(f,[b]){const z=b&1?_t(y,[b&1&&lt(f[0]),b&0&&lt(ct)]):{};b&2&&(z.$$scope={dirty:b,ctx:f}),p.$set(z)},i(f){m||(gt(p.$$.fragment,f),m=!0)},o(f){Tt(p.$$.fragment,f),m=!1},d(f){Et(p,f)}}}const ct={title:"DropNow: Peer to Peer Data Sharing Through WebRTC",date:"Aug 17, 2022",readmin:0,intro:"Quite often we need to transfer files between devices. Unfortunately, even in the modern age of technology, we still have trouble doing this securely and conveniently. We explore the implementation of WebRTC in a web application to enable peer to peer data transfer."};function Ct(U,p,m){return U.$$set=y=>{m(0,p=Me(Me({},p),pt(y)))},p=pt(p),[p]}class It extends mt{constructor(p){super(),bt(this,p,Ct,Pt,yt,{})}}export{It as default,ct as metadata};
